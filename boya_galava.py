# -*- coding: utf-8 -*-
"""BOYA GALAVA.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1nbkTAwJhzQ4eflg4MzIc0NlCeqKy36ZK

<h1 align="center"><font size="5">CONTENT-BASED FILTERING</font></h1>

Recommendation systems are a collection of algorithms used to recommend items to users based on information taken from the user. These systems have become ubiquitous, and can be commonly seen in online stores, movies databases and job finders. In this notebook, we will explore Content-based recommendation systems and implement a simple version of one using Python and the Pandas library.
"""

# For creating and manipulating structured tabular data
import pandas as pd

"""Let's set maximum rows to be displayed at any time to not more than 20"""

pd.set_option('display.max_rows', 20)

import pandas as pd
import numpy as np

from google.colab import drive
drive.mount("/content/drive")

"""### Saving the raw files from github

Both files have been saved in raw .csv format in  the code cell below, but if you want to download directly from the website, click this [link](https://grouplens.org/datasets/movielens/) and <br>
Select the file name 'ml-latest-small.zip (size: 1 MB)'
"""

movies_data = '/content/drive/MyDrive/2sem/movies.csv'
ratings_data = '/content/drive/MyDrive/2sem/ratings.csv'

"""### Defining additional NaN values"""

missing_values = ['na','--','?','-','None','none','non']

"""### Reading the data to the data frame"""

movies_df = pd.read_csv(movies_data, na_values=missing_values)
ratings_df = pd.read_csv(ratings_data, na_values=missing_values)

print('Movies_df Shape:',movies_df.shape)
movies_df

print('Ratings_df Shape:',ratings_df.shape)
ratings_df.head()

"""### Let's first explore and prepare the movies_df

Let's remove the year from the title column and place it in its own column, using the handy [extract](http://pandas.pydata.org/pandas-docs/stable/reference/api/pandas.Series.str.extract.html) function of pandas, alongside python regex.
"""

#Using regular expressions to find a year stored between parentheses
#We specify the parantheses so we don't conflict with movies that have years in their titles
movies_df['year'] = movies_df.title.str.extract('(\(\d\d\d\d\))',expand=False)
movies_df.head(3)

#Removing the parentheses
movies_df['year'] = movies_df.year.str.extract('(\d\d\d\d)',expand=False)
movies_df.head(3)

#Removing the years from the 'title' column
movies_df['title'] = movies_df.title.str.replace('(\(\d\d\d\d\))', '')
movies_df.head(3)

#Applying the strip function to get rid of any ending whitespace characters that may have appeared
movies_df['title'] = movies_df['title'].apply(lambda x: x.strip())
movies_df.head()

"""With that, let's also split the values in the Genres column into a list of Genres to simplify future use. This can be achieved by applying Python's split string function on the correct column."""

#Every genre is separated by a | so we simply have to call the split function on |
movies_df['genres'] = movies_df.genres.str.split('|')
movies_df.head()

"""Let's view summary of the data, the memory consumption and if the titles are arranged logically"""

movies_df.info()

movies_df_original_mem = movies_df.memory_usage()
movies_df_original_mem

# Let's convert movieId column from int64 to int8 to save memory space
movies_df.movieId = movies_df.movieId.astype('int32')

"""Let's check for missing values"""

movies_df.isna().sum()

"""let's fill movies_df missing year  values with 0 to indicate the year is not readily available. we have only 13 rows"""

movies_df.year.fillna(0, inplace=True)

# Let's now convert year column from int6a to int8, since it holds a max of just 4 digits of numbers. Thereby saving space.
movies_df.year = movies_df.year.astype('int16')

movies_df_new_mem = movies_df.memory_usage()

print(movies_df_original_mem)
print()
print(movies_df_new_mem)

"""Let's see a summary of the data types again"""

movies_df.dtypes

movies_df.head(3)

"""Now, let's  One-Hot-Encode the list of genres. This encoding is needed for feeding categorical data. In this case, we store every different genre in columns that contain either 1 or 0. 1 shows that a movie has that genre and 0 shows that it doesn't. Let's also store this dataframe in another variable, just incase we need the one without genres at some point.

"""

# First let's make a copy of the movies_df
movies_with_genres = movies_df.copy(deep=True)

# Let's iterate through movies_df, then append the movie genres as columns of 1s or 0s.
# 1 if that column contains movies in the genre at the present index and 0 if not.

x = []
for index, row in movies_df.iterrows():
    x.append(index)
    for genre in row['genres']:
        movies_with_genres.at[index, genre] = 1

# Confirm that every row has been iterated and acted upon
print(len(x) == len(movies_df))

movies_with_genres.head(3)

#Filling in the NaN values with 0 to show that a movie doesn't have that column's genre
movies_with_genres = movies_with_genres.fillna(0)
movies_with_genres.head(3)

"""Let's look at the ratings data set now"""

# print out the shape and first five rows of ratings data.
print('Ratings_df shape:',ratings_df.shape)
ratings_df.head()

# Dropping the timestamp column
ratings_df.drop('timestamp', axis=1, inplace=True)

# Confirming the drop
ratings_df.head(3)

# Let's confirm the right data types exist per column in ratings data_set

ratings_df.dtypes

# Let's check for missing values

ratings_df.isna().sum()

"""## Content Based recommender System

Now, let's implement a Content-Based or Item-Item recommendation systems. This technique attempts to figure out what a user's favourite aspects of an item is, and then recommends items that present those aspects.

Let's begin by creating an input user to recommend movies to. The user's name will be Hilal and we would assume Hilal has rated the following movies with the following ratings:-

Notice: To add more movies, simply increase the amount of elements in the userInput. Feel free to add more in! Just be sure to write it in with capital letters and if a movie starts with a "The", like "The Matrix" then write it in like this: 'Matrix, The' .

Step 1: Creating Hilal's Profile
"""

# so on a scale of 0 to 5, with 0 min and 5 max, see Hilal's movie ratings below
Hilal_movie_ratings = [
            {'title':'Predator', 'rating':4.9},
            {'title':'Final Destination', 'rating':4.9},
            {'title':'Mission Impossible', 'rating':4},
            {'title':"Beverly Hills Cop", 'rating':3},
            {'title':'Exorcist, The', 'rating':4.8},
            {'title':'Waiting to Exhale', 'rating':3.9},
            {'title':'Avengers, The', 'rating':4.5},
            {'title':'Omen, The', 'rating':5.0}
         ]
Hilal_movie_ratings = pd.DataFrame(Hilal_movie_ratings)
Hilal_movie_ratings

"""Add movieId to input user
With the input complete, let's extract the input movie's ID's from the movies dataframe and add them into it.

We can achieve this by first filtering out the rows that contain the input movie's title and then merging this subset with the input dataframe. We also drop unnecessary columns for the input to save memory space.
"""

# Extracting movie Ids from movies_df and updating Hilal_movie_ratings with movie Ids.

Hilal_movie_Id = movies_df[movies_df['title'].isin(Hilal_movie_ratings['title'])]

# Merging Hilal movie Id and ratings into the Hilal_movie_ratings data frame.
# This action implicitly merges both data frames by the title column.

Hilal_movie_ratings = pd.merge(Hilal_movie_Id, Hilal_movie_ratings)

# Display the merged and updated data frame.

Hilal_movie_ratings

"""Lets drop some columns that we do not need such as genres and year"""

#Dropping information we don't need such as year and genres
Hilal_movie_ratings = Hilal_movie_ratings.drop(['genres','year'], 1)


#Final input dataframe
#If a movie you added in above isn't here, then it might not be in the original
#dataframe or it might spelled differently, please check capitalisation.
Hilal_movie_ratings

"""Step 2: Learning Hilal's Profile

We're going to start by learning the input's preferences, so let's get the subset of movies that the input has watched from the Dataframe containing genres defined with binary values.
"""

# filter the selection by outputing movies that exist in both Hilal_movie_ratings and movies_with_genres
Hilal_genres_df = movies_with_genres[movies_with_genres.movieId.isin(Hilal_movie_ratings.movieId)]
Hilal_genres_df

"""We'll only need the actual genre table, so let's clean this up a bit by resetting the index and dropping the movieId, title, genres and year columns."""

# First, let's reset index to default and drop the existing index.
Hilal_genres_df.reset_index(drop=True, inplace=True)

# Next, let's drop redundant columns
Hilal_genres_df.drop(['movieId','title','genres','year'], axis=1, inplace=True)

# Let's view chamges

Hilal_genres_df

"""Step 3: Building Hilal's Profile<br>
To do this, we're going to turn each genre into weights, by multiplying Hilal's movie ratings by Hilal_genres_df table. And then summing up the resulting table by column. This operation is actually a dot product between a matrix and a vector.
First let's confirm the shapes of the data frames we have recently defined
"""

# Let's find the dot product of transpose of Hilal_genres_df by Hilal rating column
Hilal_profile = Hilal_genres_df.T.dot(Hilal_movie_ratings.rating)

# Let's see the result
Hilal_profile

"""Just by Eye-balling his profile, it is clear that Hilal loves 'Thriller', 'Action' and 'Horror' movies the mostâ€¦ apt as can be.<br>
Now, we have the weights for all his preferences. This is known as the User Profile. We can now recommend movies that satisfy Hilal.<br>
Let's start by editing the original movies_with_genres data frame that contains all movies and their genres columns.

Step 4: Deploying The Content-Based Recommender System.
"""

# let's set the index to the movieId
movies_with_genres = movies_with_genres.set_index(movies_with_genres.movieId)

# let's view the head
movies_with_genres.head()

"""Let's delete irrelevant columns from the movies_with_genres data frame that contains all 9742 movies and distinctive columns of genres."""

# Deleting four unnecessary columns.
movies_with_genres.drop(['movieId','title','genres','year'], axis=1, inplace=True)

# Viewing changes.
movies_with_genres.head()

"""With Hilal's profile and the complete list of movies and their genres in hand, we're going to take the weighted average of every movie based on his profile and recommend the top twenty movies that match his preference."""

# Multiply the genres by the weights and then take the weighted average.
recommendation_table_df = (movies_with_genres.dot(Hilal_profile)) / Hilal_profile.sum()

# Let's view the recommendation table
recommendation_table_df.head()

"""Let's sort the recommendation table in descending order"""

# Let's sort values from great to small
recommendation_table_df.sort_values(ascending=False, inplace=True)

#Just a peek at the values
recommendation_table_df.head(20)

"""Now here's the recommendation table! Complete with movie details and genres for the top 20 movies that match Hilal's profile."""

# first we make a copy of the original movies_df
copy = movies_df.copy(deep=True)

# Then we set its index to movieId
copy = copy.set_index('movieId', drop=True)

# Next we enlist the top 20 recommended movieIds we defined above
top_20_index = recommendation_table_df.index[:20].tolist()

# finally we slice these indices from the copied movies df and save in a variable
recommended_movies = copy.loc[top_20_index, :]

# Now we can display the top 20 movies in descending order of preference
recommended_movies